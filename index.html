<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sistema Solar VR</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { margin: 0; padding: 0; background: #000; font-family: Arial, sans-serif; overflow: hidden; position: fixed; width: 100%; height: 100vh; }
        
        #info { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.8); padding: 12px; border-radius: 8px; z-index: 100; max-width: 280px; font-size: 13px; transition: opacity 0.3s; }
        
        .button { position: absolute; bottom: 15px; padding: 12px 24px; color: white; border: none; border-radius: 25px; cursor: pointer; font-size: 15px; font-weight: bold; z-index: 100; transition: all 0.3s; touch-action: manipulation; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        #vr-button { right: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        #sim-vr-button { right: 180px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        #pause-button { left: 50%; transform: translateX(-50%); background: #FF9800; }
        
        .button:hover { transform: scale(1.05); }
        .button:active { transform: scale(0.95); }
        .button:disabled { background: #666; cursor: not-allowed; opacity: 0.5; }
        
        #vr-button.active { background: linear-gradient(135deg, #f5576c 0%, #c21500 100%); }
        #sim-vr-button.active { background: linear-gradient(135deg, #FF4757 0%, #FF6B6B 100%); }
        .paused { background: #2196F3 !important; }
        
        #planet-info { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: white; background: rgba(0,0,0,0.9); padding: 12px; border-radius: 10px; z-index: 60; width: 90%; max-width: 400px; display: none; pointer-events: none; border: 2px solid #4CAF50; font-size: 11px; }
        #planet-info h2 { margin: 0 0 6px 0; color: #4CAF50; font-size: 14px; text-align: center; }
        #planet-info p { margin: 3px 0; font-size: 10px; line-height: 1.3; }
        
        #vr-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 15px; z-index: 200; text-align: center; display: none; max-width: 90%; border: 3px solid #667eea; }
        #vr-overlay.visible { display: block; }
        #vr-overlay h2 { color: #667eea; margin: 0 0 15px 0; font-size: 24px; }
        #vr-overlay p { margin: 10px 0; font-size: 16px; line-height: 1.6; }
        
        .crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; z-index: 50; display: none; }
        .crosshair.active { display: block; }
        .crosshair::before, .crosshair::after { content: ''; position: absolute; background: rgba(255,255,255,0.8); }
        .crosshair::before { width: 2px; height: 20px; left: 9px; top: 0; }
        .crosshair::after { width: 20px; height: 2px; left: 0; top: 9px; }
        
        #controls { position: absolute; bottom: 20px; left: 20px; color: white; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 10px; font-size: 12px; transition: opacity 0.3s; }
        
        @media (max-width: 768px) {
            #sim-vr-button { bottom: 70px; right: 15px; }
            #controls { display: none; }
        }
    </style>
</head>
<body>
    <div id="info">
        <h3 style="margin: 0 0 8px 0;">üöÄ Sistema Solar VR</h3>
        <p><strong>Desktop:</strong> Mouse para explorar</p>
        <p><strong>VR Real:</strong> √ìculos VR compat√≠veis</p>
        <p><strong>VR Simulado:</strong> WASD + Mouse</p>
    </div>
    
    <div id="controls">
        <p>‚å®Ô∏è Controles VR Simulado:</p>
        <p>‚Ä¢ WASD: Mover</p>
        <p>‚Ä¢ Mouse: Olhar</p>
        <p>‚Ä¢ Espa√ßo/Shift: Subir/Descer</p>
        <p>‚Ä¢ Clique para travar cursor</p>
    </div>
    
    <div id="vr-overlay">
        <h2>ü•Ω Modo VR</h2>
        <p id="vr-message">Preparando experi√™ncia VR...</p>
    </div>
    
    <div id="planet-info">
        <h2 id="planet-name">Planeta</h2>
        <p id="planet-description">Descri√ß√£o</p>
        <p id="planet-distance">Dist√¢ncia</p>
        <p id="planet-size">Tamanho</p>
        <p id="planet-orbital">Per√≠odo</p>
        <p id="planet-day">Dia</p>
        <p id="planet-moons">Luas</p>
        <p id="planet-curiosity">Curiosidade</p>
    </div>
    
    <div class="crosshair" id="crosshair"></div>
    
    <button class="button" id="vr-button" disabled>üîç Verificando VR...</button>
    <button class="button" id="sim-vr-button">üéÆ VR Simulado</button>
    <button class="button" id="pause-button">‚è∏Ô∏è Pausar</button>

    <script>
        let scene, camera, renderer;
        let planets = [], sun;
        let isPaused = false;
        let moveSpeed = 0.3;
        let keys = {};
        let raycaster = new THREE.Raycaster();
        let planetInfoTimer = null;
        let vrSession = null;
        let isVRMode = false;
        let isSimVRMode = false;
        let controllers = [];

        init();
        animate();

        async function init() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 15, 40);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            await checkVRSupport();
            setupButtons();
            createSolarSystem();
            addLights();
            addMouseControls();
            setupVRControllers();
            
            window.addEventListener('resize', onWindowResize);
        }

        async function checkVRSupport() {
            const vrButton = document.getElementById('vr-button');
            
            if (!navigator.xr) {
                vrButton.textContent = '‚ùå WebXR n√£o suportado';
                vrButton.disabled = true;
                return;
            }

            try {
                const supported = await navigator.xr.isSessionSupported('immersive-vr');
                
                if (supported) {
                    vrButton.textContent = 'ü•Ω Entrar VR Real';
                    vrButton.disabled = false;
                    vrButton.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                } else {
                    vrButton.textContent = 'üì± VR n√£o dispon√≠vel';
                    vrButton.disabled = true;
                }
            } catch (error) {
                vrButton.textContent = '‚ö†Ô∏è Erro VR';
                vrButton.disabled = true;
            }
        }

        function setupButtons() {
            document.getElementById('vr-button').onclick = toggleVR;
            document.getElementById('sim-vr-button').onclick = toggleSimulatedVR;
            document.getElementById('pause-button').onclick = () => {
                isPaused = !isPaused;
                const btn = document.getElementById('pause-button');
                btn.textContent = isPaused ? '‚ñ∂Ô∏è Continuar' : '‚è∏Ô∏è Pausar';
                btn.classList.toggle('paused');
            };
        }

        async function toggleVR() {
            if (isSimVRMode) {
                toggleSimulatedVR();
            }
            
            if (vrSession) {
                await vrSession.end();
            } else {
                try {
                    showVROverlay('Conectando aos √≥culos VR...');
                    
                    vrSession = await navigator.xr.requestSession('immersive-vr', {
                        optionalFeatures: [
                            'local-floor', 
                            'bounded-floor', 
                            'hand-tracking',
                            'layers'
                        ]
                    });
                    
                    await renderer.xr.setSession(vrSession);
                    isVRMode = true;
                    
                    document.getElementById('vr-button').textContent = 'üö™ Sair VR Real';
                    document.getElementById('vr-button').classList.add('active');
                    document.getElementById('info').style.display = 'none';
                    document.getElementById('controls').style.display = 'none';
                    document.getElementById('crosshair').classList.add('active');
                    
                    camera.position.set(0, 15, 50);
                    camera.lookAt(0, 0, 0);
                    
                    showVROverlay('Modo VR ativado! Mova sua cabe√ßa para olhar ao redor.', 3000);
                    
                    vrSession.addEventListener('end', onVRSessionEnded);
                    
                } catch (error) {
                    console.error('Erro ao iniciar VR:', error);
                    showVROverlay('N√£o foi poss√≠vel iniciar o VR. Verifique seus √≥culos.', 5000);
                }
            }
        }

        function onVRSessionEnded() {
            vrSession = null;
            isVRMode = false;
            
            document.getElementById('vr-button').textContent = 'ü•Ω Entrar VR Real';
            document.getElementById('vr-button').classList.remove('active');
            document.getElementById('info').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('crosshair').classList.remove('active');
            document.getElementById('planet-info').style.display = 'none';
            
            camera.position.set(0, 15, 40);
            camera.lookAt(0, 0, 0);
        }

        function toggleSimulatedVR() {
            if (isVRMode) return;
            
            isSimVRMode = !isSimVRMode;
            const btn = document.getElementById('sim-vr-button');
            
            if (isSimVRMode) {
                btn.textContent = 'üö™ Sair VR Simulado';
                btn.classList.add('active');
                document.getElementById('crosshair').classList.add('active');
                document.getElementById('info').style.opacity = '0.3';
                document.getElementById('controls').style.opacity = '0.8';
                
                camera.position.set(0, 5, 15);
                camera.rotation.set(0, 0, 0);
                camera.lookAt(0, 0, 0);
                
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                document.addEventListener('mousemove', onSimVRMouseMove);
                document.addEventListener('click', () => {
                    if (document.body.requestPointerLock) document.body.requestPointerLock();
                });
            } else {
                btn.textContent = 'üéÆ VR Simulado';
                btn.classList.remove('active');
                document.getElementById('crosshair').classList.remove('active');
                document.getElementById('info').style.opacity = '1';
                document.getElementById('controls').style.opacity = '1';
                document.getElementById('planet-info').style.display = 'none';
                
                document.removeEventListener('keydown', onKeyDown);
                document.removeEventListener('keyup', onKeyUp);
                document.removeEventListener('mousemove', onSimVRMouseMove);
                if (document.exitPointerLock) document.exitPointerLock();
                
                camera.position.set(0, 15, 40);
                camera.rotation.set(0, 0, 0);
                camera.lookAt(0, 0, 0);
            }
        }

        function onKeyDown(e) { keys[e.code] = true; }
        function onKeyUp(e) { keys[e.code] = false; }

        function onSimVRMouseMove(e) {
            if (!isSimVRMode) return;
            camera.rotation.y -= (e.movementX || 0) * 0.002;
            camera.rotation.x -= (e.movementY || 0) * 0.002;
            camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
        }

        function updateSimVRMovement() {
            if (!isSimVRMode) return;
            const dir = new THREE.Vector3();
            if (keys['KeyW']) { camera.getWorldDirection(dir); camera.position.add(dir.multiplyScalar(moveSpeed)); }
            if (keys['KeyS']) { camera.getWorldDirection(dir); camera.position.add(dir.multiplyScalar(-moveSpeed)); }
            if (keys['KeyA']) { camera.getWorldDirection(dir); const left = new THREE.Vector3().crossVectors(camera.up, dir); camera.position.add(left.normalize().multiplyScalar(moveSpeed)); }
            if (keys['KeyD']) { camera.getWorldDirection(dir); const right = new THREE.Vector3().crossVectors(dir, camera.up); camera.position.add(right.normalize().multiplyScalar(moveSpeed)); }
            if (keys['Space']) camera.position.y += moveSpeed;
            if (keys['ShiftLeft']) camera.position.y -= moveSpeed;
        }

        function showVROverlay(message, duration = 0) {
            const overlay = document.getElementById('vr-overlay');
            const messageEl = document.getElementById('vr-message');
            messageEl.textContent = message;
            overlay.classList.add('visible');
            
            if (duration > 0) {
                setTimeout(() => {
                    overlay.classList.remove('visible');
                }, duration);
            }
        }

        function setupVRControllers() {
            const controller1 = renderer.xr.getController(0);
            scene.add(controller1);
            controllers.push(controller1);
            
            const controller2 = renderer.xr.getController(1);
            scene.add(controller2);
            controllers.push(controller2);
        }

        function createSolarSystem() {
            createStarField();
            
            const sunGeo = new THREE.SphereGeometry(3, 32, 32);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, emissive: 0xFFAA00 });
            sun = new THREE.Mesh(sunGeo, sunMat);
            sun.userData = {
                name: 'Sol',
                description: 'A estrela no centro do Sistema Solar',
                realDistance: 'Centro do Sistema',
                realSize: '1.392.700 km',
                orbitalPeriod: 'N/A',
                dayLength: '~25 dias',
                moons: '8 planetas',
                curiosity: '‚≠ê O Sol cont√©m 99,86% de toda a massa do Sistema Solar e poderia conter mais de 1 milh√£o de Terras!'
            };
            scene.add(sun);
            
            const planetData = [
                { name: 'Merc√∫rio', size: 0.5, distance: 6, color: 0x8C7853, speed: 0.01 },
                { name: 'V√™nus', size: 0.8, distance: 9, color: 0xFFA500, speed: 0.0075 },
                { name: 'Terra', size: 0.9, distance: 12, color: 0x4169E1, speed: 0.005, hasMoon: true },
                { name: 'Marte', size: 0.6, distance: 15, color: 0xFF4500, speed: 0.004 },
                { name: 'J√∫piter', size: 1.8, distance: 22, color: 0xDAA520, speed: 0.0025 },
                { name: 'Saturno', size: 1.5, distance: 28, color: 0xFAD5A5, speed: 0.002, hasRings: true }
            ];
            
            planetData.forEach(data => { 
                const p = createPlanet(data);
                planets.push(p); 
                scene.add(p.group); 
            });
        }

        function createPlanet(data) {
            const group = new THREE.Group();
            
            const orbitGeo = new THREE.RingGeometry(data.distance - 0.15, data.distance + 0.15, 64);
            const orbitMat = new THREE.MeshBasicMaterial({ 
                color: 0x444444, 
                side: THREE.DoubleSide, 
                transparent: true, 
                opacity: 0.3 
            });
            const orbit = new THREE.Mesh(orbitGeo, orbitMat);
            orbit.rotation.x = -Math.PI / 2;
            group.add(orbit);
            
            const planetGeo = new THREE.SphereGeometry(data.size, 32, 32);
            const planetMat = new THREE.MeshLambertMaterial({ color: data.color });
            const planetMesh = new THREE.Mesh(planetGeo, planetMat);
            planetMesh.position.x = data.distance;
            
            const planetInfo = {
                'Merc√∫rio': { desc: 'Menor planeta do Sistema Solar', dist: '57,9 milh√µes km', size: '4.879 km', orbital: '88 dias', day: '59 dias', moons: '0', curiosity: 'üå°Ô∏è As temperaturas variam de -173¬∞C √† noite a 427¬∞C durante o dia!' },
                'V√™nus': { desc: 'O planeta mais quente', dist: '108,2 milh√µes km', size: '12.104 km', orbital: '225 dias', day: '243 dias', moons: '0', curiosity: 'üî• Sua temperatura chega a 465¬∞C devido ao efeito estufa extremo. V√™nus gira ao contr√°rio!' },
                'Terra': { desc: 'Nosso lar, √∫nico com vida', dist: '149,6 milh√µes km', size: '12.742 km', orbital: '365,25 dias', day: '24 horas', moons: '1', curiosity: 'üåç 70% da superf√≠cie √© coberta por √°gua. √â o √∫nico lugar conhecido no universo com vida!' },
                'Marte': { desc: 'O planeta vermelho', dist: '227,9 milh√µes km', size: '6.779 km', orbital: '687 dias', day: '24,6 horas', moons: '2', curiosity: 'üî¥ Sua cor vermelha vem do √≥xido de ferro. Tem o maior vulc√£o do Sistema Solar: Monte Olimpo!' },
                'J√∫piter': { desc: 'O maior planeta', dist: '778,5 milh√µes km', size: '139.820 km', orbital: '12 anos', day: '10 horas', moons: '95', curiosity: 'üå™Ô∏è A Grande Mancha Vermelha √© uma tempestade maior que a Terra que dura h√° 400 anos!' },
                'Saturno': { desc: 'Famoso pelos an√©is', dist: '1,4 bilh√£o km', size: '116.460 km', orbital: '29 anos', day: '10,7 horas', moons: '146', curiosity: 'üíç Seus an√©is s√£o feitos de bilh√µes de peda√ßos de gelo e rocha. Saturno √© t√£o leve que flutuaria na √°gua!' }
            };
            
            const info = planetInfo[data.name];
            planetMesh.userData = {
                name: data.name,
                description: info.desc,
                realDistance: info.dist,
                realSize: info.size,
                orbitalPeriod: info.orbital,
                dayLength: info.day,
                moons: info.moons,
                curiosity: info.curiosity
            };
            
            group.add(planetMesh);
            
            if (data.hasMoon) {
                const moonGeo = new THREE.SphereGeometry(data.size * 0.27, 16, 16);
                const moonMat = new THREE.MeshLambertMaterial({ color: 0xAAAAAA });
                const moon = new THREE.Mesh(moonGeo, moonMat);
                moon.position.x = data.size * 3;
                moon.userData = {
                    name: 'Lua',
                    description: 'O √∫nico sat√©lite natural da Terra',
                    realDistance: '384.400 km da Terra',
                    realSize: 'Di√¢metro: 3.474 km',
                    orbitalPeriod: '√ìrbita: 27,3 dias terrestres',
                    dayLength: 'Rota√ß√£o: 27,3 dias (sincronizada)',
                    moons: 'Sat√©lite da Terra',
                    curiosity: 'üåô A Lua sempre mostra a mesma face para a Terra! Ela se afasta 3,8 cm por ano.'
                };
                planetMesh.add(moon);
            }
            
            if (data.hasRings) {
                const ringGeo = new THREE.RingGeometry(data.size * 1.2, data.size * 2.2, 32);
                const ringMat = new THREE.MeshLambertMaterial({ 
                    color: 0xC4A484, 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0.7 
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                planetMesh.add(ring);
            }
            
            return { group: group, planet: planetMesh, data: data, angle: Math.random() * Math.PI * 2 };
        }

        function createStarField() {
            const starGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(50000);
            for (let i = 0; i < 50000; i++) {
                positions[i] = (Math.random() - 0.5) * 3000;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.7 }));
            scene.add(stars);
        }

        function addLights() {
            const sunLight = new THREE.PointLight(0xFFFFFF, 2.5, 200);
            sunLight.castShadow = true;
            scene.add(sunLight);
            
            const ambient = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambient);
        }

        function addMouseControls() {
            document.addEventListener('mousemove', (e) => {
                if (isVRMode || isSimVRMode) return;
                
                const mx = (e.clientX / window.innerWidth) * 2 - 1;
                const my = -(e.clientY / window.innerHeight) * 2 + 1;
                camera.position.x = Math.sin(mx * Math.PI) * 40;
                camera.position.z = Math.cos(mx * Math.PI) * 40;
                camera.position.y = my * 20 + 15;
                camera.lookAt(0, 0, 0);
            });
            
            document.addEventListener('wheel', (e) => {
                if (isVRMode || isSimVRMode) return;
                const dist = camera.position.length();
                const newDist = Math.max(20, Math.min(100, dist + e.deltaY * 0.05));
                camera.position.normalize().multiplyScalar(newDist);
            });
        }

        function checkPlanetIntersection() {
            if (!isVRMode && !isSimVRMode) return;
            
            const planetInfo = document.getElementById('planet-info');
            if (!planetInfo) return;
            
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const planetMeshes = planets.map(p => p.planet);
            const allObjects = [...planetMeshes, sun];
            const intersects = raycaster.intersectObjects(allObjects, true);
            
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj && !obj.userData.name) obj = obj.parent;
                
                if (obj && obj.userData.name) {
                    document.getElementById('planet-name').textContent = obj.userData.name;
                    document.getElementById('planet-description').textContent = obj.userData.description;
                    document.getElementById('planet-distance').textContent = 'üìç ' + obj.userData.realDistance;
                    document.getElementById('planet-size').textContent = 'üåê ' + obj.userData.realSize;
                    document.getElementById('planet-orbital').textContent = 'üîÑ ' + obj.userData.orbitalPeriod;
                    document.getElementById('planet-day').textContent = '‚è∞ ' + obj.userData.dayLength;
                    document.getElementById('planet-moons').textContent = 'üåô ' + obj.userData.moons;
                    document.getElementById('planet-curiosity').textContent = obj.userData.curiosity;
                    
                    planetInfo.style.display = 'block';
                    if (planetInfoTimer) clearTimeout(planetInfoTimer);
                }
            } else {
                if (planetInfo.style.display === 'block' && !planetInfoTimer) {
                    planetInfoTimer = setTimeout(() => {
                        planetInfo.style.display = 'none';
                        planetInfoTimer = null;
                    }, 3000);
                }
            }
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            updateSimVRMovement();
            checkPlanetIntersection();
            
            if (!isPaused) {
                sun.rotation.y += 0.002;
                
                planets.forEach(p => {
                    p.angle += p.data.speed;
                    p.planet.position.x = Math.cos(p.angle) * p.data.distance;
                    p.planet.position.z = Math.sin(p.angle) * p.data.distance;
                    p.planet.rotation.y += 0.005;
                });
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
