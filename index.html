<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema Solar ‚Äî VR Real (Sem Simulado)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/vr/WebXR.js"></script>
    <style>
        *{box-sizing:border-box}
        html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Arial,Helvetica,sans-serif}
        #canvas-container{position:fixed;inset:0}
        #ui{position:fixed;left:12px;top:12px;color:#fff;background:rgba(0,0,0,0.6);padding:10px;border-radius:8px;z-index:60;max-width:320px;font-size:13px}
        #planet-info{position:fixed;right:12px;top:12px;color:#fff;background:rgba(0,0,0,0.7);padding:12px;border-radius:8px;z-index:60;width:280px;display:none;font-size:13px}
        #planet-info h3{margin:0 0 6px 0;color:#8BC34A}
        #vr-button{position:fixed;right:12px;bottom:12px;padding:12px 18px;border-radius:22px;border:0;background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;font-weight:700;z-index:70}
        #hint{position:fixed;left:50%;bottom:16px;transform:translateX(-50%);color:#fff;background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:999px;font-size:13px;z-index:60}
        .marker-label{pointer-events:none;font-size:12px;color:#fff}
        @media (max-width:720px){#ui{max-width:240px;font-size:12px}#planet-info{width:220px;font-size:12px}}
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="ui">
        <strong>üöÄ Sistema Solar</strong>
        <div style="margin-top:6px">Toque e arraste = girar c√¢mera ‚Ä¢ Pinch = zoom ‚Ä¢ Bot√£o VR = entrar em VR real</div>
    </div>

    <div id="planet-info" aria-hidden="true">
        <h3 id="pi-name">Planeta</h3>
        <div id="pi-desc"></div>
        <div id="pi-dist"></div>
        <div id="pi-size"></div>
        <div id="pi-orb"></div>
        <div id="pi-day"></div>
        <div id="pi-moons"></div>
        <div id="pi-curio" style="margin-top:6px;color:#FFD54F"></div>
    </div>

    <button id="vr-button">üîç Verificar VR...</button>
    <div id="hint">Se o bot√£o VR ficar ativo, entre com √≥culos compat√≠veis (WebXR)</div>

<script>
/*
  Vers√£o final: somente VR real (WebXR). Removido modo VR simulado e stereo hacks.
  Corre√ß√µes importantes para mobile:
  - Touch drag + pinch zoom implementados (funcionam no celular)
  - Gaze raycast no centro para mostrar info
  - Marcador 3D (ring + label) aparece sobre o planeta apontado
  - Bot√£o VR usa navigator.xr quando dispon√≠vel
*/

let container = document.getElementById('canvas-container');
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.set(0, 6, 28);

let renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
container.appendChild(renderer.domElement);

// Lights
const amb = new THREE.AmbientLight(0xffffff, 0.25); scene.add(amb);
const sunLight = new THREE.PointLight(0xffffff, 2, 400); sunLight.position.set(0,0,0); scene.add(sunLight);

// Fixed small fog for depth
scene.fog = new THREE.FogExp2(0x000000, 0.0006);

// Star field
function createStarField(count = 12000){
  const g = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);
  for(let i=0;i<count;i++){
    const r = 400 + Math.random()*800;
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos((Math.random()*2)-1);
    positions[i*3] = Math.sin(phi)*Math.cos(theta)*r;
    positions[i*3+1] = Math.sin(phi)*Math.sin(theta)*r;
    positions[i*3+2] = Math.cos(phi)*r;
  }
  g.setAttribute('position', new THREE.BufferAttribute(positions,3));
  const m = new THREE.PointsMaterial({ size: 0.7, sizeAttenuation: true });
  const pts = new THREE.Points(g,m);
  scene.add(pts);
}
createStarField();

// Sun
const sunGeo = new THREE.SphereGeometry(3.5, 32, 32);
const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFD54F });
const sun = new THREE.Mesh(sunGeo, sunMat);
sun.userData = { name:'Sol', description:'Estrela central', realDistance:'Centro', realSize:'1.392.700 km', orbitalPeriod:'-', dayLength:'~25 dias', moons:'8 planetas', curiosity:'Cont√©m 99.8% da massa do Sistema Solar' };
scene.add(sun);

// Planets data
const planetSpecs = [
  {name:'Merc√∫rio', size:0.45, dist:6, color:0x8C7853, speed:0.012},
  {name:'V√™nus', size:0.7, dist:9, color:0xE68A00, speed:0.008},
  {name:'Terra', size:0.85, dist:12, color:0x2A65C4, speed:0.006, moon:true},
  {name:'Marte', size:0.55, dist:15, color:0xD94E1A, speed:0.005},
  {name:'J√∫piter', size:1.8, dist:21, color:0xD4A84E, speed:0.003},
  {name:'Saturno', size:1.4, dist:26, color:0xEFD7B5, speed:0.002, rings:true}
];

const planets = [];
function buildPlanets(){
  const info = {
    'Merc√∫rio':{desc:'Menor planeta',dist:'57,9 milh√µes km',size:'4.879 km',orb:'88 dias',day:'59 dias',moons:'0',cur:'Temperaturas extremas'},
    'V√™nus':{desc:'Planeta mais quente',dist:'108,2 milh√µes km',size:'12.104 km',orb:'225 dias',day:'243 dias',moons:'0',cur:'Gira ao contr√°rio'},
    'Terra':{desc:'Nosso lar',dist:'149,6 milh√µes km',size:'12.742 km',orb:'365 dias',day:'24h',moons:'1',cur:'70% √°gua'},
    'Marte':{desc:'Planeta vermelho',dist:'227,9 milh√µes km',size:'6.779 km',orb:'687 dias',day:'24.6h',moons:'2',cur:'Monte Olimpo'},
    'J√∫piter':{desc:'O maior',dist:'778,5 milh√µes km',size:'139.820 km',orb:'12 anos',day:'10h',moons:'95',cur:'Grande Mancha Vermelha'},
    'Saturno':{desc:'An√©is famosos',dist:'1,4 bi km',size:'116.460 km',orb:'29 anos',day:'10.7h',moons:'146',cur:'An√©is de gelo'}
  };

  planetSpecs.forEach(s => {
    const g = new THREE.Group();
    const orb = new THREE.RingGeometry(s.dist-0.08, s.dist+0.08, 64);
    const orbMesh = new THREE.Mesh(orb, new THREE.MeshBasicMaterial({color:0x333333, side:THREE.DoubleSide, transparent:true, opacity:0.25}));
    orbMesh.rotation.x = -Math.PI/2; g.add(orbMesh);

    const m = new THREE.Mesh(new THREE.SphereGeometry(s.size, 32, 32), new THREE.MeshLambertMaterial({color:s.color}));
    m.position.x = s.dist;
    const pname = s.name;
    m.userData = Object.assign({name:pname}, info[pname]);
    g.add(m);

    if(s.moon){
      const moon = new THREE.Mesh(new THREE.SphereGeometry(s.size*0.28, 16,16), new THREE.MeshLambertMaterial({color:0x999999}));
      moon.position.set(s.size*2.4,0,0);
      m.add(moon);
    }
    if(s.rings){
      const r = new THREE.Mesh(new THREE.RingGeometry(s.size*1.2,s.size*1.9,32), new THREE.MeshLambertMaterial({side:THREE.DoubleSide,transparent:true,opacity:0.7}));
      r.rotation.x = -Math.PI/2; m.add(r);
    }

    scene.add(g);
    planets.push({group:g, mesh:m, spec:s, angle:Math.random()*Math.PI*2});
  });
}
buildPlanets();

// Marker: ring + label that appears above the target planet
const marker = new THREE.Group();
const ringGeo = new THREE.RingGeometry(0.9,1.1,32);
const ringMat = new THREE.MeshBasicMaterial({color:0x43A047, side:THREE.DoubleSide, transparent:true, opacity:0.95});
const ring = new THREE.Mesh(ringGeo, ringMat); ring.rotation.x = -Math.PI/2; marker.add(ring);
const markerSprite = document.createElement('div');
markerSprite.className = 'marker-label';
markerSprite.style.padding = '4px 8px';
markerSprite.style.background = 'rgba(0,0,0,0.6)';
markerSprite.style.borderRadius = '6px';
markerSprite.style.color = '#fff';
markerSprite.style.fontSize = '12px';
markerSprite.textContent = '';
const cssObject = new THREE.CSS2DObject ? null : null; // placeholder: we will use DOM overlay instead
// We'll position marker in 3D and sync a DOM label on screen
scene.add(marker);
let domLabel = document.createElement('div'); domLabel.className='marker-label'; domLabel.style.position='fixed'; domLabel.style.pointerEvents='none'; domLabel.style.transform='translate(-50%,-140%)'; domLabel.style.display='none'; domLabel.style.padding='4px 8px'; domLabel.style.background='rgba(33,150,243,0.9)'; domLabel.style.borderRadius='6px'; domLabel.style.fontSize='12px'; domLabel.style.zIndex='80'; domLabel.style.color='#fff'; document.body.appendChild(domLabel);

// Raycaster center
const raycaster = new THREE.Raycaster();

// Touch / mouse controls (orbit + pinch)
let isTouching=false, lastTouchDist=0, lastX=0, lastY=0, rotY=0, rotX=0;

renderer.domElement.addEventListener('touchstart', e=>{
  if(e.touches.length===1){ isTouching=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; }
  if(e.touches.length===2){ lastTouchDist = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);} 
}, {passive:false});

renderer.domElement.addEventListener('touchmove', e=>{
  e.preventDefault();
  if(e.touches.length===1 && isTouching){
    const dx = e.touches[0].clientX - lastX; const dy = e.touches[0].clientY - lastY;
    rotY -= dx * 0.003; rotX -= dy * 0.003; rotX = Math.max(-1.4, Math.min(1.4, rotX));
    updateCameraFromOrbit();
    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
  } else if(e.touches.length===2){
    const d = Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
    const delta = d - lastTouchDist; lastTouchDist = d;
    // zoom
    const len = camera.position.length();
    let newLen = Math.max(8, Math.min(120, len - delta*0.03));
    camera.position.normalize().multiplyScalar(newLen);
  }
}, {passive:false});

renderer.domElement.addEventListener('touchend', e=>{ if(e.touches.length===0) isTouching=false; }, {passive:false});

// Mouse for desktop
let isDragging=false, prevMouseX=0, prevMouseY=0;
renderer.domElement.addEventListener('mousedown', e=>{isDragging=true; prevMouseX=e.clientX; prevMouseY=e.clientY;});
window.addEventListener('mousemove', e=>{ if(isDragging){ const dx=e.clientX-prevMouseX, dy=e.clientY-prevMouseY; rotY -= dx*0.003; rotX -= dy*0.003; rotX = Math.max(-1.4, Math.min(1.4, rotX)); updateCameraFromOrbit(); prevMouseX=e.clientX; prevMouseY=e.clientY;} });
window.addEventListener('mouseup', ()=>isDragging=false);
window.addEventListener('wheel', e=>{ const len=camera.position.length(); let nl=Math.max(8,Math.min(120,len+e.deltaY*0.01)); camera.position.normalize().multiplyScalar(nl); });

function updateCameraFromOrbit(){
  const r = camera.position.length();
  camera.position.x = Math.sin(rotY) * r;
  camera.position.z = Math.cos(rotY) * r;
  camera.position.y = rotX * 8 + 6;
  camera.lookAt(0,2,0);
}

// Basic resize
window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

// VR button logic (WebXR)
const vrBtn = document.getElementById('vr-button');
async function checkVR(){
  if(navigator.xr && navigator.xr.isSessionSupported){
    try{
      const ok = await navigator.xr.isSessionSupported('immersive-vr');
      if(ok){ vrBtn.textContent = 'ü•Ω Entrar VR Real'; vrBtn.disabled = false; }
      else { vrBtn.textContent = '‚ùå VR n√£o dispon√≠vel'; vrBtn.disabled = true; }
    }catch(e){ vrBtn.textContent='‚ö†Ô∏è Erro VR'; vrBtn.disabled=true; }
  } else { vrBtn.textContent='‚ùå WebXR n√£o suportado'; vrBtn.disabled=true; }
}
checkVR();

vrBtn.addEventListener('click', async ()=>{
  if(!navigator.xr) return alert('WebXR n√£o suportado neste navegador');
  if(vrBtn.dataset.session==='on'){
    // end session
    const s = renderer.xr.getSession(); if(s) await s.end(); return;
  }
  try{
    const session = await navigator.xr.requestSession('immersive-vr', {optionalFeatures:['local-floor','bounded-floor']});
    await renderer.xr.setSession(session);
    vrBtn.dataset.session='on'; vrBtn.textContent='üö™ Sair VR';
    session.addEventListener('end', ()=>{ vrBtn.dataset.session=''; vrBtn.textContent='ü•Ω Entrar VR Real'; });
  }catch(err){ console.error(err); alert('N√£o foi poss√≠vel iniciar a sess√£o VR'); }
});

// Raycast + marker + UI update
const screenCenter = new THREE.Vector2(0,0);
const piName = document.getElementById('pi-name');
const piDesc = document.getElementById('pi-desc');
const piDist = document.getElementById('pi-dist');
const piSize = document.getElementById('pi-size');
const piOrb = document.getElementById('pi-orb');
const piDay = document.getElementById('pi-day');
const piMoons = document.getElementById('pi-moons');
const piCurio = document.getElementById('pi-curio');
const pInfoDiv = document.getElementById('planet-info');

function updateRaycastAndMarker(){
  // perform raycast from camera center
  raycaster.setFromCamera(screenCenter, camera);
  const targets = planets.map(p=>p.mesh).concat(sun);
  const hits = raycaster.intersectObjects(targets, true);
  if(hits.length>0){
    let o = hits[0].object;
    while(o && !o.userData.name) o = o.parent;
    if(o && o.userData && o.userData.name){
      // show marker above object
      const worldPos = new THREE.Vector3(); o.getWorldPosition(worldPos);
      marker.position.copy(worldPos);
      marker.position.y += (o.geometry ? o.geometry.parameters.radius || 1 : 1) + 0.6;
      marker.scale.setScalar((o.geometry ? o.geometry.parameters.radius || 1 : 1) * 0.9);
      marker.visible = true;

      // project to screen to position DOM label
      const v = worldPos.clone().project(camera);
      const x = (v.x * .5 + .5) * window.innerWidth;
      const y = ( - v.y * .5 + .5) * window.innerHeight;
      domLabel.style.left = x + 'px'; domLabel.style.top = (y - 24) + 'px'; domLabel.textContent = o.userData.name; domLabel.style.display='block';

      // update info panel
      piName.textContent = o.userData.name;
      piDesc.textContent = o.userData.description || '';
      piDist.textContent = 'üìç ' + (o.userData.realDistance || '‚Äî');
      piSize.textContent = 'üåê ' + (o.userData.realSize || '‚Äî');
      piOrb.textContent = 'üîÑ ' + (o.userData.orbitalPeriod || '‚Äî');
      piDay.textContent = '‚è∞ ' + (o.userData.dayLength || '‚Äî');
      piMoons.textContent = 'üåô ' + (o.userData.moons || '‚Äî');
      piCurio.textContent = o.userData.curiosity || '';
      pInfoDiv.style.display = 'block';
      if(window._hideTimeout){ clearTimeout(window._hideTimeout); window._hideTimeout=null; }
    }
  } else {
    // hide marker after short delay
    if(!window._hideTimeout){ window._hideTimeout = setTimeout(()=>{ marker.visible=false; domLabel.style.display='none'; pInfoDiv.style.display='none'; window._hideTimeout=null; }, 900); }
  }
}

// add marker to scene (initially hidden)
marker.visible = false; scene.add(marker);

// Animation loop
let last = performance.now();
function animate(t){
  const dt = (t - last) * 0.001; last = t;
  // animate sun + planets
  sun.rotation.y += 0.3 * dt;
  planets.forEach(p=>{
    p.angle += p.spec.speed * dt * 60;
    p.mesh.position.x = Math.cos(p.angle) * p.spec.dist;
    p.mesh.position.z = Math.sin(p.angle) * p.spec.dist;
    p.mesh.rotation.y += 0.5 * dt;
  });

  updateRaycastAndMarker();
  renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);

// ensure scene visible on very small screens by setting camera
function ensureMobileView(){
  if(window.innerWidth <= 720){ camera.position.set(0,5,36); }
}
ensureMobileView();
window.addEventListener('resize', ensureMobileView);

// initial camera target
camera.lookAt(0,2,0);

</script>
</body>
</html>
