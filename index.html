<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Sistema Solar VR - WebXR</title>

    <!-- Three.js r128 (compatÃ­vel com muitos exemplos) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        #container { width: 100%; height: 100vh; position: relative; }

        #ui-overlay {
            position: absolute; left: 12px; top: 12px; background: rgba(0,0,0,0.6); color: #fff; padding: 12px; border-radius: 8px; z-index: 20; max-width: 360px; font-size: 13px;
        }

        #enter-vr { position: absolute; right: 12px; top: 12px; z-index: 30; padding: 10px 14px; background: linear-gradient(45deg,#4CAF50,#2E7D32); color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }
        #enter-vr.hidden { display: none; }

        #planet-info-dom {
            position: absolute; right: 12px; bottom: 12px; z-index: 30; width: 320px; background: rgba(0,0,0,0.7); color: #fff; border-radius: 10px; padding: 12px; display: none;
        }
        #planet-info-dom h3 { margin: 0 0 6px 0; color: #FFEB3B; }
        #planet-info-dom p { margin: 6px 0; font-size: 13px; line-height: 1.3; }

        .hint { font-size: 12px; opacity: 0.9; }

        /* small helper for development so you can see the reticle on a 2D screen */
        #reticle-2d { position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); width: 10px; height: 10px; background: white; border-radius: 50%; opacity: 0.85; z-index: 10; pointer-events: none; display: none; }

        .button-secondary { background: linear-gradient(45deg,#9C27B0,#E91E63); border: none; color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; }

        #info-floating { position: absolute; left: 12px; bottom: 12px; z-index: 30; color: #fff; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; font-size: 13px; }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="ui-overlay">
        <strong>ðŸš€ Sistema Solar VR â€” Modo WebXR</strong>
        <div class="hint">Use um Ã³culos VR compatÃ­vel com WebXR (Ex: Meta Quest via navegador compatÃ­vel) ou testar no desktop com WebXR-emulation.</div>
        <div style="margin-top:8px; display:flex; gap:8px;">
            <button id="enter-vr" class="button-secondary">Entrar em VR</button>
            <button id="show-2d-reticle">Mostrar mira 2D</button>
        </div>
    </div>

    <div id="planet-info-dom">
        <h3 id="pname">Planeta</h3>
        <p id="pdesc">DescriÃ§Ã£o</p>
        <p id="pmeta">â€”</p>
        <div style="display:flex; gap:8px; margin-top:8px;"><button id="close-info" class="button-secondary">Fechar</button></div>
    </div>

    <div id="info-floating">Olhe para um planeta (mire com a cabeÃ§a). A marca (ponto) na sua testa aponta para o que vocÃª olhou.</div>
    <div id="reticle-2d"></div>

    <script>
    // VersÃ£o atualizada: WebXR + mira fixa (marca na fronte) + painel info 3D/DOM

    let container = document.getElementById('container');
    let scene = new THREE.Scene();
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true; // Habilita WebXR
    container.appendChild(renderer.domElement);

    // Camera "regular" usada para nÃ£o-XR (preview)
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 6);

    // Um grupo para representar o 'head' â€” serve para adicionar a marca na fronte
    const head = new THREE.Group();
    head.position.set(0, 1.6, 0);
    scene.add(head);

    // Marca (ponto) na fronte â€” sempre fica um pouco Ã  frente da cabeÃ§a
    const foreheadMarkerGeo = new THREE.SphereGeometry(0.02, 8, 8);
    const foreheadMarkerMat = new THREE.MeshBasicMaterial({ color: 0x00FFCC, emissive: 0x00FFCC });
    const foreheadMarker = new THREE.Mesh(foreheadMarkerGeo, foreheadMarkerMat);
    foreheadMarker.position.set(0, 0, -0.12); // estÃ¡ frente ao "olho"
    head.add(foreheadMarker);

    // Um pequeno retÃ­culo 3D (visÃ­vel no mundo) â€” o marcador apontarÃ¡ para o planeta e vai se posicionar sobre ele quando houver intersecÃ§Ã£o
    const gazeReticleGeo = new THREE.RingGeometry(0.06, 0.09, 32);
    const gazeReticleMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
    const gazeReticle = new THREE.Mesh(gazeReticleGeo, gazeReticleMat);
    gazeReticle.rotation.x = -Math.PI/2;
    gazeReticle.visible = false;
    scene.add(gazeReticle);

    // Luzes
    scene.add(new THREE.HemisphereLight(0x8888ff, 0x222233, 0.6));
    const sunLight = new THREE.PointLight(0xFFFFFF, 2, 200);
    scene.add(sunLight);

    // Sol
    const sunGeo = new THREE.SphereGeometry(1.2, 32, 32);
    const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFD54F });
    const sun = new THREE.Mesh(sunGeo, sunMat);
    sun.userData = { name: 'Sol', description: 'A estrela central do Sistema Solar', curiosity: 'ContÃ©m 99.86% da massa do Sistema Solar.' };
    scene.add(sun);

    // Planetas (dados reduzidos e estilizados â€” vocÃª pode ampliar)
    const planets = [];
    const planetDefs = [
        { name: 'MercÃºrio', size: 0.12, distance: 2.6, color: 0x8C7853, speed: 0.012, desc: 'Menor planeta.' , meta: 'Dist: 57,9M km â€¢ Dia: 59 dias'},
        { name: 'VÃªnus', size: 0.2, distance: 3.6, color: 0xFFA500, speed: 0.009, desc: 'Planeta extremamente quente.' , meta: 'Dist: 108M km â€¢ Dia: 243 dias'},
        { name: 'Terra', size: 0.21, distance: 4.6, color: 0x2E86FF, speed: 0.007, desc: 'Nosso lar, com vida.', meta: 'Dist: 149M km â€¢ Lua: 1'},
        { name: 'Marte', size: 0.16, distance: 5.6, color: 0xFF4500, speed: 0.006, desc: 'O planeta vermelho.', meta: 'Dist: 228M km â€¢ Lua: 2'},
        { name: 'JÃºpiter', size: 0.45, distance: 7.8, color: 0xD4A017, speed: 0.004, desc: 'Gigante gasoso.', meta: 'Dist: 778M km â€¢ Muitas luas'},
        { name: 'Saturno', size: 0.38, distance: 9.6, color: 0xEFD5A5, speed: 0.003, desc: 'Conhecido por seus anÃ©is.', meta: 'Dist: 1,4B km â€¢ AnÃ©is visÃ­veis'}
    ];

    planetDefs.forEach(d => {
        const g = new THREE.Group();
        const geo = new THREE.SphereGeometry(d.size, 32, 32);
        const mat = new THREE.MeshStandardMaterial({ color: d.color, roughness: 0.8 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(d.distance, 0, 0);
        mesh.userData = { name: d.name, description: d.desc, curiosity: d.meta };

        // Ã“rbita visual
        const orbitGeo = new THREE.RingGeometry(d.distance - 0.01, d.distance + 0.01, 64);
        const orbitMat = new THREE.MeshBasicMaterial({ color: 0x444444, side: THREE.DoubleSide, transparent: true, opacity: 0.25 });
        const orbit = new THREE.Mesh(orbitGeo, orbitMat);
        orbit.rotation.x = -Math.PI/2;
        scene.add(orbit);

        g.add(mesh);
        scene.add(g);
        planets.push({ group: g, mesh: mesh, def: d, angle: Math.random() * Math.PI * 2 });
    });

    // Raycaster (usado para detectar o que a cabeÃ§a estÃ¡ olhando)
    const raycaster = new THREE.Raycaster();
    const tempVec = new THREE.Vector3();

    // DOM Info
    const planetInfoDOM = document.getElementById('planet-info-dom');
    const pname = document.getElementById('pname');
    const pdesc = document.getElementById('pdesc');
    const pmeta = document.getElementById('pmeta');
    document.getElementById('close-info').addEventListener('click', () => { planetInfoDOM.style.display = 'none'; });

    // Pequeno helper para mostrar reticle 2d (Ãºtil para visualizaÃ§Ã£o em desktop)
    const reticle2d = document.getElementById('reticle-2d');
    document.getElementById('show-2d-reticle').addEventListener('click', () => { reticle2d.style.display = (reticle2d.style.display === 'none') ? 'block' : 'none'; });

    // AnimaÃ§Ã£o de Ã³rbitas
    function updateOrbits(delta) {
        planets.forEach(p => {
            p.angle += p.def.speed * delta * 60; // ajuste de velocidade
            const x = Math.cos(p.angle) * p.def.distance;
            const z = Math.sin(p.angle) * p.def.distance;
            p.mesh.position.set(x, 0, z);
            // girando o prÃ³prio planeta
            p.mesh.rotation.y += 0.01;
        });
        sun.rotation.y += 0.002 * delta * 60;
    }

    // FunÃ§Ã£o que calcula onde o marcador na fronte estÃ¡ apontando
    function updateGazeInteraction() {
        // A posiÃ§Ã£o "olho" real em world-space â€” usamos gerenciador XR quando em sessÃ£o
        let xrCamera = renderer.xr.getCamera();
        let origin = new THREE.Vector3();
        let dir = new THREE.Vector3(0,0,-1);

        if (renderer.xr.isPresenting) {
            // xrCamera Ã© um ArrayCamera; pegar a cÃ¢mera principal (0)
            origin.setFromMatrixPosition(xrCamera.cameras[0].matrixWorld);
            // DireÃ§Ã£o: usar a rotaÃ§Ã£o do head group (aqui assumimos que o head estÃ¡ alinhado com a cÃ¢mera XR local)
            const camQuaternion = new THREE.Quaternion();
            xrCamera.cameras[0].getWorldQuaternion(camQuaternion);
            dir.applyQuaternion(camQuaternion);
        } else {
            // fallback desktop: usar camera normal
            origin.copy(head.getWorldPosition(new THREE.Vector3()));
            const quat = head.getWorldQuaternion(new THREE.Quaternion());
            dir.set(0,0,-1).applyQuaternion(quat);
        }

        raycaster.set(origin, dir);
        const meshes = planets.map(p => p.mesh).concat([sun]);
        const intersects = raycaster.intersectObjects(meshes, false);

        if (intersects.length > 0) {
            const it = intersects[0];
            // Posicionar reticle 3D sobre a superfÃ­cie do objeto intersectado
            gazeReticle.position.copy(it.point);
            gazeReticle.visible = true;

            // Mostrar o painel DOM com informaÃ§Ãµes
            const ud = it.object.userData;
            if (ud && ud.name) {
                pname.textContent = ud.name;
                pdesc.textContent = ud.description || '';
                pmeta.textContent = ud.curiosity || '';
                planetInfoDOM.style.display = 'block';
            }

            // RealÃ§ar o planeta levemente (pequena escala de destaque)
            it.object.scale.set(1.06,1.06,1.06);

            // posicionar grÃ¡fico/indicador â€” opcional: animate marker to planet
        } else {
            gazeReticle.visible = false;
            // reset highlights
            planets.forEach(p => p.mesh.scale.set(1,1,1));
            // oculta DOM info apÃ³s 1.5s
            if (planetInfoDOM.style.display === 'block') {
                // deixamos visÃ­vel por enquanto; vocÃª pode ocultar com timeout se preferir
            }
        }
    }

    // Torna o ponto 'foreheadMarker' seguir a cÃ¢mera XR automaticamente.
    // Quando em sessÃ£o XR, atualizamos a posiÃ§Ã£o do 'head' para acompanhar a cÃ¢mera.
    function syncHeadToXR() {
        if (renderer.xr.isPresenting) {
            const xrCam = renderer.xr.getCamera();
            // Pegar posiÃ§Ã£o do primeiro sub-cÃ¢mera (esquerdo/direito)
            const worldPos = new THREE.Vector3();
            worldPos.setFromMatrixPosition(xrCam.cameras[0].matrixWorld);
            head.position.copy(worldPos);
            // Copiar rotaÃ§Ã£o do xr camera para o head
            const worldQuat = new THREE.Quaternion();
            xrCam.cameras[0].getWorldQuaternion(worldQuat);
            head.quaternion.copy(worldQuat);
        } else {
            // head segue a 'camera' normal
            head.position.copy(camera.position);
            head.quaternion.copy(camera.quaternion);
        }
    }

    // BotÃ£o "Entrar em VR" â€” tenta iniciar uma sessÃ£o WebXR de imersÃ£o
    const enterVRBtn = document.getElementById('enter-vr');
    async function initXR() {
        if (navigator.xr) {
            const isSupported = await navigator.xr.isSessionSupported('immersive-vr');
            if (!isSupported) {
                enterVRBtn.textContent = 'VR nÃ£o suportado';
                enterVRBtn.disabled = true;
                return;
            }

            enterVRBtn.addEventListener('click', async () => {
                try {
                    const session = await navigator.xr.requestSession('immersive-vr', { requiredFeatures: ['local-floor'] });
                    renderer.xr.setSession(session);
                } catch (err) {
                    console.warn('Falha ao iniciar sessÃ£o XR:', err);
                    alert('NÃ£o foi possÃ­vel iniciar a sessÃ£o VR. Verifique o headset e o navegador.');
                }
            });
        } else {
            enterVRBtn.textContent = 'WebXR nÃ£o disponÃ­vel';
            enterVRBtn.disabled = true;
        }
    }

    initXR();

    // InteraÃ§Ã£o: apontar/controlar com o controlador (opcional) â€” adiciona reticle quando controlador disponÃ­vel
    const controller = renderer.xr.getController(0);
    controller.addEventListener('select', () => {
        // Ao pressionar o gatilho enquanto olha para um planeta, podemos travar info ou aproximar
        if (gazeReticle.visible) {
            // Exemplo: ocultar/mostrar informaÃ§Ã£o DOM jÃ¡ tratado por gaze
        }
    });
    scene.add(controller);

    // Resize handler
    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    });

    // loop principal â€” usando renderer.setAnimationLoop para compatibilidade XR
    let lastTime = performance.now();
    renderer.setAnimationLoop((time) => {
        const delta = (time - lastTime) / 1000;
        lastTime = time;

        // atualizar Ã³rbitas
        updateOrbits(delta);

        // sincronizar head com cÃ¢mera XR (manter a marca na fronte alinhada)
        syncHeadToXR();

        // raycast a partir do ponto de vista da "testa" / cabeÃ§a
        updateGazeInteraction();

        // render
        if (renderer.xr.isPresenting) {
            renderer.render(scene, camera); // quando em XR, o renderer substitui a cÃ¢mera automaticamente
        } else {
            renderer.render(scene, camera);
        }
    });

    // Mostrar reticle 2D para testes em desktop
    // O reticle 2D fica no centro da tela â€” replicando olhando com a testa
    function updateReticle2DVisibility() {
        // se nÃ£o estiver em XR, mostra o reticle 2D por conveniÃªncia
        if (!renderer.xr.isPresenting) {
            document.getElementById('show-2d-reticle').style.display = 'inline-block';
        } else {
            document.getElementById('show-2d-reticle').style.display = 'none';
        }
    }
    updateReticle2DVisibility();

    // Ativar pequenos controles (mouse) para testar sem Ã³culos
    let isPointerDown = false;
    let lastX = 0, lastY = 0;
    window.addEventListener('pointerdown', (e) => { isPointerDown = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener('pointerup', () => { isPointerDown = false; });
    window.addEventListener('pointermove', (e) => {
        if (!isPointerDown || renderer.xr.isPresenting) return;
        const dx = (e.clientX - lastX) * 0.002;
        const dy = (e.clientY - lastY) * 0.002;
        camera.rotation.y -= dx;
        camera.rotation.x -= dy;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
        lastX = e.clientX; lastY = e.clientY;
    });

    // DEBUG: Exibir posiÃ§Ã£o inicial dos objetos no console (Ãºtil para desenvolvimento)
    console.log('Planetas inicializados:', planets.map(p => p.mesh.userData.name));

    // Ao entrar/sair de sessÃ£o XR, ajustar UI e visibilidade do reticle 2D
    renderer.xr.addEventListener('sessionstart', () => {
        enterVRBtn.classList.add('hidden');
        document.getElementById('info-floating').style.display = 'none';
        reticle2d.style.display = 'none';
    });
    renderer.xr.addEventListener('sessionend', () => {
        enterVRBtn.classList.remove('hidden');
        document.getElementById('info-floating').style.display = 'block';
        updateReticle2DVisibility();
    });

    // Acessibilidade: permitir foco no planeta por clique no DOM (Ãºtil para desktop)
    document.getElementById('ui-overlay').addEventListener('click', (e) => {
        // placeholder
    });

    </script>
</body>
</html>
