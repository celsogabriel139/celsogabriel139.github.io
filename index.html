<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Sistema Solar VR - Completo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        #container { width: 100%; height: 100vh; position: relative; }

        #ui { position: absolute; left: 12px; top: 12px; z-index: 40; color: #fff; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; max-width: 360px; font-size: 13px; }
        #enter-vr { position: absolute; right: 12px; top: 12px; z-index: 40; padding: 10px 14px; background: linear-gradient(45deg,#4CAF50,#2E7D32); color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }
        #info-panel { position: absolute; right: 12px; bottom: 12px; z-index: 40; width: 320px; background: rgba(0,0,0,0.75); color: #fff; border-radius: 10px; padding: 12px; display: none; }
        #info-panel h3 { margin: 0 0 6px 0; color: #FFD54F }
        #reticle-2d { position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); width: 8px; height: 8px; background: rgba(255,255,255,0.9); border-radius: 50%; z-index: 30; pointer-events: none; display: none; }
        #loading { position:absolute; left:50%; top:50%; transform: translate(-50%,-50%); z-index:50; color:#fff; background:rgba(0,0,0,0.7); padding:12px; border-radius:8px; }
    </style>
</head>
<body>
<div id="container"></div>
<div id="ui">üöÄ <strong>Sistema Solar VR</strong><div style="font-size:12px;opacity:0.9;margin-top:6px">Use um headset compat√≠vel com WebXR ou teste no desktop. Mire com a cabe√ßa para ver informa√ß√µes.</div></div>
<button id="enter-vr">Entrar em VR</button>
<div id="info-panel">
    <h3 id="ip-name">Planeta</h3>
    <p id="ip-desc">Descri√ß√£o</p>
    <p id="ip-meta">‚Äî</p>
    <div style="margin-top:8px;"><button id="ip-close">Fechar</button></div>
</div>
<div id="reticle-2d"></div>
<div id="loading">Carregando Sistema Solar...</div>

<script>
// Sistema Solar completo para WebXR + mira (marcador na fronte) + Lua + painel informativo

const container = document.getElementById('container');
const infoPanel = document.getElementById('info-panel');
const ipName = document.getElementById('ip-name');
const ipDesc = document.getElementById('ip-desc');
const ipMeta = document.getElementById('ip-meta');
const ipClose = document.getElementById('ip-close');
const reticle2d = document.getElementById('reticle-2d');
const loading = document.getElementById('loading');

ipClose.addEventListener('click', () => { infoPanel.style.display = 'none'; });

// Renderer + XR
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
container.appendChild(renderer.domElement);

// Cena e c√¢mera
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, 40); // Come√ßar fora do sistema para ver tudo

// Grupo central para o sistema (facilita rotacionar tudo devagar)
const systemGroup = new THREE.Group();
scene.add(systemGroup);

// Marca na fronte: um pequeno objeto que fica sempre um pouco em frente ao usu√°rio
const head = new THREE.Group();
scene.add(head);
head.position.set(0, 1.6, 0);
const forehead = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), new THREE.MeshBasicMaterial({ color: 0x00ffcc, emissive: 0x00ffcc }));
forehead.position.set(0, 0, -0.12);
head.add(forehead);

// Reticle 3D que aparece sobre o planeta quando olhamos para ele
const retGeo = new THREE.RingGeometry(0.12, 0.17, 32);
const retMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true });
const gazeReticle = new THREE.Mesh(retGeo, retMat);
gazeReticle.rotation.x = -Math.PI/2;
gazeReticle.visible = false;
scene.add(gazeReticle);

// Luzes
const ambient = new THREE.AmbientLight(0x666666, 0.6);
scene.add(ambient);
const sunLight = new THREE.PointLight(0xffffff, 2.2, 1000);
scene.add(sunLight);

// Sol
const sunGeom = new THREE.SphereGeometry(3, 64, 64);
const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFD54F });
const sun = new THREE.Mesh(sunGeom, sunMat);
sun.userData = { name: 'Sol', description: 'Estrela do nosso sistema.', meta: 'Massa: 1.989√ó10^30 kg' };
systemGroup.add(sun);

// Planetas com Lua
const planets = [];
const defs = [
    { name: 'Merc√∫rio', size: 0.3, dist: 7, color: 0x8C7853, speed: 0.012, desc: 'Menor planeta.' , meta: 'Dist: 57,9M km'},
    { name: 'V√™nus', size: 0.6, dist: 10, color: 0xD98B3B, speed: 0.008, desc: 'Planeta quente e denso.' , meta: 'Dist: 108M km'},
    { name: 'Terra', size: 0.65, dist: 14, color: 0x2E86FF, speed: 0.006, desc: 'Nosso lar.' , meta: 'Dist: 149,6M km'},
    { name: 'Marte', size: 0.45, dist: 18, color: 0xFF4500, speed: 0.005, desc: 'Planeta vermelho.' , meta: 'Dist: 227,9M km'},
    { name: 'J√∫piter', size: 1.4, dist: 24, color: 0xD4A017, speed: 0.0035, desc: 'O maior planeta.' , meta: 'Dist: 778,5M km'},
    { name: 'Saturno', size: 1.1, dist: 30, color: 0xEFD5A5, speed: 0.0028, desc: 'An√©is impressionantes.' , meta: 'Dist: 1,4B km'}
];

// criar √≥rbitas e planetas
defs.forEach((d, i) => {
    const orbit = new THREE.RingGeometry(d.dist - 0.02, d.dist + 0.02, 128);
    const orbitMesh = new THREE.Mesh(orbit, new THREE.MeshBasicMaterial({ color: 0x444444, side: THREE.DoubleSide, transparent: true, opacity: 0.25 }));
    orbitMesh.rotation.x = -Math.PI/2;
    systemGroup.add(orbitMesh);

    const planetGeo = new THREE.SphereGeometry(d.size, 32, 32);
    const planetMat = new THREE.MeshStandardMaterial({ color: d.color, roughness: 0.8, metalness: 0.1 });
    const planet = new THREE.Mesh(planetGeo, planetMat);
    planet.position.set(d.dist, 0, 0);
    planet.userData = { name: d.name, description: d.desc, meta: d.meta };
    systemGroup.add(planet);

    // An√©is para Saturno
    if (d.name === 'Saturno') {
        const ringGeo = new THREE.RingGeometry(d.size * 1.4, d.size * 2.2, 64);
        const ringMat = new THREE.MeshStandardMaterial({ color: 0xC4A484, side: THREE.DoubleSide, transparent: true, opacity: 0.75 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = -Math.PI/2;
        ring.position.copy(planet.position);
        systemGroup.add(ring);
    }

    planets.push({ mesh: planet, def: d, angle: Math.random() * Math.PI * 2 });
});

// Lua da Terra: criamos um grupo orbital para a Terra e adicionamos a lua
const earthObj = planets.find(p => p.def.name === 'Terra');
let moon = null;
if (earthObj) {
    const moonGeo = new THREE.SphereGeometry(0.18, 16, 16);
    const moonMat = new THREE.MeshStandardMaterial({ color: 0xAAAAAA });
    moon = new THREE.Mesh(moonGeo, moonMat);
    // posicionar inicialmente perto da Terra
    moon.position.set(earthObj.def.dist + 1.2, 0, 0);
    moon.userData = { name: 'Lua', description: 'Sat√©lite natural da Terra.', meta: 'Dist: 384.400 km' };
    systemGroup.add(moon);
}

// Fundo de estrelas (skybox simples pontilhado)
const starGeo = new THREE.BufferGeometry();
const starCount = 5000;
const positions = new Float32Array(starCount * 3);
for (let i = 0; i < starCount * 3; i++) positions[i] = (Math.random() - 0.5) * 2000;
starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.5 }));
scene.add(stars);

// Raycaster para detectar o que a testa est√° olhando
const raycaster = new THREE.Raycaster();

// Fun√ß√£o que atualiza posi√ß√µes orbitais e rota√ß√£o lenta do sistema
function updateSystem(delta) {
    // girar todo o sistema lentamente para dar sensa√ß√£o de movimento
    systemGroup.rotation.y += 0.02 * delta; // rota√ß√£o global lenta

    // √≥rbitas individuais
    planets.forEach(p => {
        p.angle += p.def.speed * delta * 60; // ajustar velocidade
        const x = Math.cos(p.angle) * p.def.dist;
        const z = Math.sin(p.angle) * p.def.dist;
        p.mesh.position.set(x, 0, z);
        p.mesh.rotation.y += 0.002 * delta * 60;
    });

    // lua orbita a Terra
    if (moon && earthObj) {
        // encontrar posi√ß√£o da Terra
        const earthPos = earthObj.mesh.position.clone();
        const moonAngle = performance.now() * 0.0006; // velocidade da lua
        const mx = earthPos.x + Math.cos(moonAngle) * 1.2;
        const mz = earthPos.z + Math.sin(moonAngle) * 1.2;
        moon.position.set(mx, 0, mz);
        moon.rotation.y += 0.01;
    }
}

// Fun√ß√£o que faz raycast a partir do ponto da testa (forehead)
let lastIntersection = null;
let hideInfoTimeout = null;
function updateGaze() {
    let origin = new THREE.Vector3();
    let dir = new THREE.Vector3(0,0,-1);

    if (renderer.xr.isPresenting) {
        const xrCamera = renderer.xr.getCamera();
        // usar a primeira sub-c√¢mera para origem
        origin.setFromMatrixPosition(xrCamera.cameras[0].matrixWorld);
        const quat = new THREE.Quaternion();
        xrCamera.cameras[0].getWorldQuaternion(quat);
        dir.set(0,0,-1).applyQuaternion(quat);
        // tamb√©m sincronizar o 'head' group para que o marcador apare√ßa corretamente no mundo
        head.position.copy(origin);
        head.quaternion.copy(quat);
    } else {
        // fallback: usar c√¢mera regular + head alinhado
        origin.copy(camera.position);
        dir.set(0,0,-1).applyQuaternion(camera.quaternion);
        head.position.copy(camera.position);
        head.quaternion.copy(camera.quaternion);
    }

    raycaster.set(origin, dir);
    const targets = planets.map(p => p.mesh).concat([sun]);
    if (moon) targets.push(moon);
    const hits = raycaster.intersectObjects(targets, false);

    if (hits.length > 0) {
        const it = hits[0];
        lastIntersection = it;
        // posicionar reticle 3D sobre o ponto
        gazeReticle.position.copy(it.point);
        gazeReticle.visible = true;
        // mostrar DOM info imediatamente
        const ud = it.object.userData || {};
        if (ud.name) {
            ipName.textContent = ud.name;
            ipDesc.textContent = ud.description || '';
            ipMeta.textContent = ud.meta || '';
            infoPanel.style.display = 'block';
            // manter info vis√≠vel enquanto olhar
            if (hideInfoTimeout) { clearTimeout(hideInfoTimeout); hideInfoTimeout = null; }
        }
    } else {
        gazeReticle.visible = false;
        // se n√£o houver interse√ß√£o, esconder painel ap√≥s um curto tempo
        if (!hideInfoTimeout && infoPanel.style.display === 'block') {
            hideInfoTimeout = setTimeout(() => { infoPanel.style.display = 'none'; hideInfoTimeout = null; }, 1500);
        }
    }
}

// Bot√£o Entrar em VR
const enterBtn = document.getElementById('enter-vr');
async function initXR() {
    if (navigator.xr) {
        const supported = await navigator.xr.isSessionSupported('immersive-vr');
        if (!supported) { enterBtn.textContent = 'VR n√£o suportado'; enterBtn.disabled = true; return; }
        enterBtn.addEventListener('click', async () => {
            try {
                const session = await navigator.xr.requestSession('immersive-vr', { requiredFeatures: ['local-floor'] });
                renderer.xr.setSession(session);
            } catch (err) {
                alert('Falha ao iniciar VR: ' + err.message);
            }
        });
    } else {
        enterBtn.textContent = 'WebXR n√£o dispon√≠vel'; enterBtn.disabled = true;
    }
}
initXR();

// Controller select (opcional): ao apertar gatilho, fixamos/ocultamos info
const controller = renderer.xr.getController(0);
controller.addEventListener('select', () => {
    if (lastIntersection) {
        // alterna fixo do painel
        if (infoPanel.dataset.locked === 'true') {
            infoPanel.style.display = 'none';
            infoPanel.dataset.locked = 'false';
        } else {
            infoPanel.dataset.locked = 'true';
            infoPanel.style.display = 'block';
        }
    }
});
scene.add(controller);

// Loop principal
let last = performance.now();
renderer.setAnimationLoop((now) => {
    const delta = (now - last) / 1000; last = now;
    updateSystem(delta);
    updateGaze();
    // manter luz do sol em posi√ß√£o do sol
    sunLight.position.copy(sun.position);
    renderer.render(scene, camera);
});

// Ajustes de resize
window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
});

// Ativa reticle 2D para teste sem headset
function updateReticle2D() {
    if (!renderer.xr.isPresenting) { reticle2d.style.display = 'block'; } else { reticle2d.style.display = 'none'; }
}
updateReticle2D();
renderer.xr.addEventListener('sessionstart', () => { enterBtn.style.display = 'none'; updateReticle2D(); loading.style.display = 'none'; });
renderer.xr.addEventListener('sessionend', () => { enterBtn.style.display = 'block'; updateReticle2D(); });

// Remover loading ao terminar setup
setTimeout(() => { loading.style.display = 'none'; }, 800);

// Controles mouse para testar em desktop
let down = false, lx = 0, ly = 0;
window.addEventListener('pointerdown', (e) => { down = true; lx = e.clientX; ly = e.clientY; });
window.addEventListener('pointerup', () => { down = false; });
window.addEventListener('pointermove', (e) => {
    if (!down || renderer.xr.isPresenting) return;
    const dx = (e.clientX - lx) * 0.002; const dy = (e.clientY - ly) * 0.002;
    camera.rotation.y -= dx; camera.rotation.x -= dy;
    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
    lx = e.clientX; ly = e.clientY;
});

console.log('Sistema Solar pronto.');
</script>
</body>
</html>
